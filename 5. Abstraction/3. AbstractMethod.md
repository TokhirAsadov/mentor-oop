# Java'da Abstrakt Metodlar va Ularning Cheklovlari

Abstrakt metodlar Java'da faqat abstrakt sinflar yoki interfeyslar ichida aniqlanadi va ularning muayyan cheklovlari mavjud. Quyida har bir cheklov uchun tushuntirish va misollar keltiriladi.

## 1. Abstrakt metod faqat abstrakt sinfda e'lon qilinishi mumkin
Abstrakt metod oddiy (konkret) sinfda aniqlanmaydi, chunki u tanasiz bo'lib, merosxo'r sinf tomonidan amalga oshirilishi shart. Agar oddiy sinfda abstrakt metod aniqlansa, kompilyatsiya xatosi yuzaga keladi.

**Misol**:
```java
// Xato: Oddiy sinfda abstrakt metod aniqlanmaydi
class RegularClass {
    abstract void doSomething(); // Kompilyatsiya xatosi: RegularClass is not abstract
}

// To'g'ri: Abstrakt sinfda abstrakt metod
abstract class AbstractClass {
    abstract void doSomething();
}

class ConcreteClass extends AbstractClass {
    void doSomething() {
        System.out.println("Doing something in ConcreteClass");
    }
}

public class Main {
    public static void main(String[] args) {
        ConcreteClass obj = new ConcreteClass();
        obj.doSomething(); // Natija: Doing something in ConcreteClass
    }
}
```
**Tushuntirish**: Yuqoridagi misolda `RegularClass` oddiy sinf bo'lib, unda abstrakt metod aniqlashga urinish kompilyatsiya xatosiga olib keladi. `AbstractClass` esa abstrakt sinf sifatida to'g'ri ishlaydi.

## 2. Abstrakt metodning ko'rinish sohasi (visibility) o'zgartirib bo'lmaydi (sukut bo'yicha `public` yoki `protected`)
Abstrakt metodlar merosxo'r sinflar tomonidan amalga oshirilishi uchun ochiq bo'lishi kerak. Shuning uchun ular `public` yoki `protected` ko'rinish sohasiga ega bo'ladi. `private` yoki boshqa cheklovchi ko'rinish sohasi ishlatilmaydi.

**Misol**:
```java
abstract class Shape {
    // To'g'ri: public abstrakt metod
    public abstract void draw();
    
    // To'g'ri: protected abstrakt metod
    protected abstract void resize();
    
    // Xato: private abstrakt metod aniqlab bo'lmaydi
    // private abstract void move(); // Kompilyatsiya xatosi
}

class Circle extends Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
    
    protected void resize() {
        System.out.println("Resizing Circle");
    }
}

public class Main {
    public static void main(String[] args) {
        Circle circle = new Circle();
        circle.draw();   // Natija: Drawing Circle
        circle.resize(); // Natija: Resizing Circle
    }
}
```
**Tushuntirish**: `draw` va `resize` metodlari `public` va `protected` sifatida aniqlangan, bu to'g'ri. Ammo `private` sifatida aniqlashga urinish kompilyatsiya xatosiga olib keladi, chunki `private` metodlar merosxo'r sinflarga ko'rinmaydi.

## 3. Abstrakt metod `static` bo'la olmaydi
`static` metodlar sinfga bog'liq bo'lib, ob'ektlardan mustaqil ishlaydi. Abstrakt metodlar esa merosxo'r sinflarda ob'ekt orqali amalga oshirilishi uchun mo'ljallangan, shuning uchun `static` modifikatori ishlatilmaydi.

**Misol**:
```java
abstract class Example {
    // Xato: abstrakt metod static bo'la olmaydi
    // abstract static void staticMethod(); // Kompilyatsiya xatosi
    
    // To'g'ri: abstrakt metod
    abstract void instanceMethod();
    
    // To'g'ri: static metod, lekin abstrakt emas
    static void staticMethod() {
        System.out.println("Static method in abstract class");
    }
}

class Implementation extends Example {
    void instanceMethod() {
        System.out.println("Implementing instance method");
    }
}

public class Main {
    public static void main(String[] args) {
        Implementation obj = new Implementation();
        obj.instanceMethod(); // Natija: Implementing instance method
        Example.staticMethod(); // Natija: Static method in abstract class
    }
}
```
**Tushuntirish**: `staticMethod` abstrakt sifatida aniqlansa, kompilyatsiya xatosi yuzaga keladi. Ammo oddiy `static` metod abstrakt sinfda aniqlanishi mumkin.

## 4. Abstrakt metod `final` bo'la olmaydi
`final` metodlar merosxo'r sinflarda qayta aniqlanmaydi yoki o'zgartirilmaydi. Abstrakt metodlar esa merosxo'r sinflarda majburiy ravishda amalga oshirilishi kerak, shuning uchun `final` modifikatori ishlatilmaydi.

**Misol**:
```java
abstract class Vehicle {
    // Xato: abstrakt metod final bo'la olmaydi
    // abstract final void start(); // Kompilyatsiya xatosi
    
    // To'g'ri: abstrakt metod
    abstract void start();
    
    // To'g'ri: final metod, lekin abstrakt emas
    final void stop() {
        System.out.println("Vehicle stopped");
    }
}

class Car extends Vehicle {
    void start() {
        System.out.println("Car started");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start(); // Natija: Car started
        car.stop();  // Natija: Vehicle stopped
    }
}
```
**Tushuntirish**: `start` metodi abstrakt sifatida aniqlangan va merosxo'r sinfda amalga oshirilgan. Agar `final` modifikatori ishlatilsa, kompilyatsiya xatosi yuzaga keladi, chunki `final` metodlar qayta aniqlanmaydi.

## Real Dunyo Misollari
- **Transport vositasi**: Abstrakt sinf sifatida `Vehicle` sinfi umumiy metodlarni (masalan, `start`) aniqlaydi. Har bir transport turi (`Car`, `Bike`) bu metodni o'ziga xos tarzda amalga oshiradi. `private`, `static` yoki `final` metodlar bunday umumiy shablonlarda ishlatilmaydi.
- **Bank tizimi**: Abstrakt sinf sifatida `BankAccount` sinfi `withdraw` kabi metodlarni aniqlaydi, lekin uni `private` yoki `final` qilib bo'lmaydi, chunki turli hisob turlari uni o'ziga xos tarzda amalga oshirishi kerak.

## E'tibor beriladigan jihatlar
- Abstrakt metodlar faqat merosxo'r sinflarga ochiq bo'lishi uchun `public` yoki `protected` ko'rinish sohasiga ega bo'ladi.
- `static` va `final` modifikatorlari abstrakt metodlarning maqsadini (meros orqali amalga oshirish) buzadi, shuning uchun ulardan foydalanib bo'lmaydi.
- Abstrakt metodlar polimorfizmni ta'minlash uchun ishlatiladi, shuning uchun ularni to'g'ri loyihalash muhim.

## Xulosa
Abstrakt metodlar Java'da umumiy shablonlarni yaratishda muhim rol o'ynaydi, lekin ular faqat abstrakt sinflarda aniqlanadi va `private`, `static` yoki `final` bo'la olmaydi. Yuqoridagi misollar har bir cheklovni aniq ko'rsatadi va ularni amalda qo'llashni tushuntiradi.
